3:I[4707,[],""]
5:I[6423,[],""]
6:I[7148,["972","static/chunks/972-743ded4e43f7b1b6.js","185","static/chunks/app/layout-29c38d5a84a78cb9.js"],"default"]
2:T14d0,<h3>It all started with a comment</h3>
<p>A few weeks back, I came across a very confusing comment in one of the projects I have been working on. Here‚Äôs the modified screenshot (and the code is <a href="https://github.com/cmxiv/kotlin-playground/blob/polymorphic-serialization/src/main/kotlin/Main.kt">here</a>) (All the classes have their names changed to protect their privacy üòõ)</p>
<p><img src="/images/creating_random_vehicle.png" alt="" title="Creating Random Vehicle"></p>
<p>The comment mentions that the casting is required for the code to work properly, however, IDEA is quite confident that we can remove it. Everything also works fine after we take the suggestion from IDEA to remove this casting.</p>
<p>What's going on here? Why did we need this casting (thus the comment)? Let‚Äôs (git) blame and see the diff!</p>
<p><img src="/images/the_mystifying_comment.png" alt="" title="The Mystifying Comment"></p>
<p>Let's see the output from <a href="https://github.com/cmxiv/kotlin-playground/blob/d9c04b2b7736c78fbc2e0461f2e62d76af3270ef/src/main/kotlin/Main.kt">the code on the left</a> and compare that to the output from <a href="https://github.com/cmxiv/kotlin-playground/blob/bb88f462624e76aa1790548a218133f6a9441175/src/main/kotlin/Main.kt">the code on the right</a>.</p>
<p><img src="/images/output_left_no_types.png" alt="" title="Output left: no type(s)!"></p>
<p><img src="/images/output_right_yay_types.png" alt="" title="Output right: Yay, type(s)!"></p>
<h3>Things gets interesting</h3>
<p>Those were interesting outputs, the polymorphic serialization works for <strong><em>engine</em></strong> but not for <strong><em>vehicle</em></strong>. Let's read the documentation for <strong><em>Json.encodeToString</em></strong> to dig a bit deeper.</p>
<p><img src="/images/documentation.png" alt="" title="Documentation"></p>
<p>So, the type of the passed value is being used to determine the serializer, that means <strong><em>when</em></strong> is doing some magic with the resulting types. Let's see what the documentation for <strong><em>when</em></strong> has to say about it.</p>
<p>Nothing! There's noting in <a href="https://kotlinlang.org/docs/control-flow.html#when-expression">the documentation</a> about how <strong><em>when</em></strong> decides the returning type (at the time of writing this article). Let's go to the <a href="https://kotlinlang.org/spec/expressions.html#when-expressions">Kotlin language specification</a> for it.</p>
<blockquote>
<p>The type of the resulting when expression is the <a href="https://kotlinlang.org/spec/type-system.html#least-upper-bound">least upper bound</a> of the types of all its entries. If when expression is not exhaustive, it has type kotlin.Unit and may be used only as a statement.</p>
</blockquote>
<p>Now the left output makes sense, the <strong><em>engine</em></strong>'s when expression is resolving its return type to <strong><em>Engine</em></strong> sealed class however the <strong><em>vehicle</em></strong>'s when expression is resolving its return type to <strong><em>Bike</em></strong> class NOT to <strong><em>Vehicle</em></strong> sealed class. (We can also verify it by enabling the 'Local variable types' inlay hints, see screenshots below)</p>
<p><img src="/images/enabling_local_variable_types.png" alt="" title="Enabling local variable types"></p>
<p><img src="/images/type_engine.png" alt="" title="Type: Engine"></p>
<p><img src="/images/type_bike.png" alt="" title="Type: Bike"></p>
<p>Based on these resultant return types, the <strong><em>Json.encodeToString</em></strong> function is resolving the relevant serializers, the <strong><em>Engine.serializer()</em></strong> and the <strong><em>Bike.serializer()</em></strong> respectively. Thereby giving us the output where the polymorphic <strong><em>Engine.serializer()</em></strong> adds types to the various engines but the <strong><em>Bike.serializer()</em></strong> doesn't.</p>
<p>Going back to the comment from where we started this investigation, the casting worked as the type was being derived from passed value type which was forced to be <strong><em>Vehicle</em></strong> sealed class. Also, the suggestion from IDEA makes sense as we introduced a new branch of <strong><em>CAR</em></strong> vehicle type, the resultant type for <strong><em>vehicle</em></strong>'s when expression changed to <strong><em>Vehicle</em></strong> sealed class, thereby using the intended polymorphic <strong><em>Vehicle.serializer()</em></strong>.</p>
<p><img src="/images/type_vehicle.png" alt="" title="Type: Vehicle"></p>
<h3>Summary</h3>
<p><strong><em>when</em></strong> expressions decide what to return by the least upper bound of types of all the entries. We should be mindful of this fact when introducing branches/entries in the existing <strong><em>when</em></strong> expression.</p>
<p>Instead of casting using <strong><em>as</em></strong> we could also have achieved the same results:</p>
<ol>
<li>By defining the type explicitly eg. <strong>val vehicle: Vehicle = when (vehicleType) { ... }</strong></li>
<li>By passing the intended serializer along with the value to be serialized eg. <strong>Json.encodeToString(Vehicle.serializer(), vehicle)</strong></li>
<li>By passing the type to derive the serializer eg. <strong>Json.encodeToString(vehicle)</strong></li>
</ol>4:["slug","when-confused","d"]
0:["F5TJdd5OpN8upwcveBumM",[[["",{"children":["blog",{"children":["posts",{"children":[["slug","when-confused","d"],{"children":["__PAGE__?{\"slug\":\"when-confused\"}",{}]}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":["posts",{"children":[["slug","when-confused","d"],{"children":["__PAGE__",{},[["$L1",["$","article",null,{"className":"page_post__v5Ig1","children":[["$","header",null,{"className":"mb-8 text-center","children":[["$","h1",null,{"className":"text-3xl font-bold","children":"When Confused?!"}],["$","time",null,{"dateTime":"2024-07-14T00:00:00.000Z","className":"text-gray-600","children":"Jul 14, 2024"}]]}],["$","div",null,{"className":"page_postContent__ZaqYw","dangerouslySetInnerHTML":{"__html":"$2"}}]]}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/af4b4ce9626dccd6.css","precedence":"next","crossOrigin":"$undefined"}]]],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","posts","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","posts","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/dd441fd30d11dce9.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","children":[null,["$","body",null,{"className":"roboto-regular antialiased mx-auto max-w-2xl py-8","children":[["$","$L6",null,{}],["$","section",null,{"className":"mx-auto max-w-xl py-8 overflow-hidden","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]]}]],null],null],["$L7",null]]]]
7:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"When Confused?!"}],["$","meta","3",{"name":"description","content":"JVM lover‚òïÔ∏è‚ù§Ô∏è\nSpace Enthusiast üöÄ\nAmateur chef üë®üèΩ‚Äçüç≥"}],["$","link","4",{"rel":"apple-touch-icon","href":"/apple-touch-icon.png","sizes":"180x180"}],["$","link","5",{"rel":"icon","href":"/favicon-16x16.png","type":"image/png","sizes":"16x16"}],["$","link","6",{"rel":"icon","href":"/favicon-32x32.png","type":"image/png","sizes":"32x32"}]]
1:null
